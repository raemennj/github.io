<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BattleCalc – Battleship Companion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #10141a;
      --panel-bg: #181e26;
      --accent: #4fc3f7;
      --accent-soft: rgba(79, 195, 247, 0.2);
      --hit: #ff5252;
      --miss: #90a4ae;
      --grid-line: #263238;
      --cell-size: 2.2rem;
      --prob-low: #263238;
      --prob-mid: #4fc3f7;
      --prob-high: #ffab40;
      --text: #eceff1;
      --muted: #90a4ae;
      --radius: 0.5rem;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at 20% 20%, #1b2633, #05070a);
      color: var(--text);
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }

    .app {
      width: min(1100px, 100vw);
      padding: 1rem;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.75rem;
      gap: 0.5rem;
    }

    header h1 {
      font-size: 1.3rem;
      margin: 0;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 2fr;
      gap: 1rem;
    }

    @media (max-width: 800px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: linear-gradient(145deg, #121822, #0b1017);
      border-radius: var(--radius);
      padding: 0.75rem;
      box-shadow:
        0 18px 35px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      position: relative;
    }

    .panel h2 {
      margin: 0 0 0.4rem;
      font-size: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel h2 span {
      font-size: 0.75rem;
      color: var(--muted);
      font-weight: normal;
    }

    .board-wrapper {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.25rem;
      align-items: flex-start;
    }

    .labels-col {
      display: grid;
      grid-template-rows: repeat(10, var(--cell-size));
      gap: 1px;
      font-size: 0.75rem;
      color: var(--muted);
      padding-top: 0.1rem;
    }

    .labels-row {
      display: grid;
      grid-template-columns: repeat(10, var(--cell-size));
      gap: 1px;
      font-size: 0.75rem;
      color: var(--muted);
      margin-left: calc(var(--cell-size) + 0.25rem);
      margin-bottom: 0.25rem;
    }

    .labels-row span,
    .labels-col span {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(10, var(--cell-size));
      grid-template-rows: repeat(10, var(--cell-size));
      gap: 1px;
      background-color: var(--grid-line);
      padding: 0.25rem;
      border-radius: 0.4rem;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      background-image: radial-gradient(
        circle at 10% 0,
        rgba(79, 195, 247, 0.18),
        transparent 55%
      );
    }

    .cell {
      background-color: #0a1016;
      position: relative;
      cursor: pointer;
      border-radius: 0.18rem;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      transition:
        background-color 0.15s ease-out,
        box-shadow 0.15s ease-out,
        transform 0.05s ease-out;
      user-select: none;
    }

    .cell:hover {
      box-shadow: 0 0 0 1px rgba(79, 195, 247, 0.7);
    }

    .cell.state-miss {
      background-color: rgba(144, 164, 174, 0.28);
    }

    .cell.state-hit {
      background: radial-gradient(circle at 30% 25%, #ffebee, #ff5252);
      box-shadow:
        0 0 10px rgba(255, 82, 82, 0.7),
        inset 0 0 0 1px rgba(0, 0, 0, 0.6);
      color: #fff;
      font-weight: 600;
    }

    .cell.state-hit::after {
      content: "×";
      font-size: 1.1rem;
    }

    .cell.state-miss::after {
      content: "•";
      font-size: 1.1rem;
      color: rgba(236, 239, 241, 0.8);
    }

    .cell.state-unknown::after {
      content: "";
    }

    /* Probability overlay (my shots board only) */
    .cell[data-prob] {
      /* A subtle glow; actual color is set inline from JS */
      box-shadow: 0 0 0 1px rgba(2, 5, 10, 0.5);
    }

    .controls {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    .strategy-label {
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    .strategy-select {
      background: rgba(5, 8, 12, 0.9);
      border: 1px solid var(--grid-line);
      border-radius: var(--radius);
      color: var(--text);
      padding: 0.25rem 0.65rem;
      font-size: 0.85rem;
      min-width: 9rem;
    }

    .seg-label {
      font-size: 0.8rem;
      color: var(--muted);
      margin-right: 0.4rem;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 0.35rem 0.9rem;
      font-size: 0.8rem;
      cursor: pointer;
      background: radial-gradient(circle at 30% 20%, #4fc3f7, #0288d1);
      color: #0b1016;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      box-shadow:
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 1px rgba(255, 255, 255, 0.07);
      transition:
        transform 0.05s ease-out,
        box-shadow 0.1s ease-out,
        filter 0.1s ease-out;
    }

    button:hover {
      filter: brightness(1.1);
      box-shadow:
        0 10px 20px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.1);
    }

    button:active {
      transform: translateY(1px);
      box-shadow:
        0 5px 10px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    .controls small {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .legend-swatch {
      width: 0.9rem;
      height: 0.9rem;
      border-radius: 0.2rem;
      background: var(--grid-line);
    }

    .legend-swatch.hit {
      background: radial-gradient(circle at 30% 25%, #ffebee, #ff5252);
    }

    .legend-swatch.miss {
      background-color: rgba(144, 164, 174, 0.6);
    }

    .legend-swatch.low {
      background-color: var(--prob-low);
    }

    .legend-swatch.mid {
      background-color: var(--prob-mid);
    }

    .legend-swatch.high {
      background-color: var(--prob-high);
    }

    .ships-inline {
      font-size: 0.7rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>BattleCalc</h1>
      <span>Tap cells: Unknown → Miss → Hit → Unknown</span>
    </header>

    <div class="layout">
      <!-- My shots on enemy (probability board) -->
      <section class="panel">
        <h2>
          My shots on enemy
          <span>(heatmap suggests best targets)</span>
        </h2>

        <div class="labels-row">
          <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span>
          <span>6</span><span>7</span><span>8</span><span>9</span><span>10</span>
        </div>

        <div class="board-wrapper">
          <div class="labels-col">
            <span>A</span><span>B</span><span>C</span><span>D</span><span>E</span>
            <span>F</span><span>G</span><span>H</span><span>I</span><span>J</span>
          </div>
          <div
            class="board"
            id="myShotsBoard"
            aria-label="My shots on enemy board"
          ></div>
        </div>

        <div class="legend">
          <div class="legend-item">
            <span class="legend-swatch hit"></span> Hit
          </div>
          <div class="legend-item">
            <span class="legend-swatch miss"></span> Miss
          </div>
          <div class="legend-item">
            <span class="legend-swatch low"></span> Low probability
          </div>
          <div class="legend-item">
            <span class="legend-swatch mid"></span> Medium
          </div>
          <div class="legend-item">
            <span class="legend-swatch high"></span> High
          </div>
        </div>

        <div class="ships-inline">
          Fleet: Carrier (5), Battleship (4), Cruiser (3), Submarine (3),
          Destroyer (2)
        </div>
      </section>

      <!-- Enemy shots on me (tracking only for now) -->
      <section class="panel">
        <h2>
          Enemy shots on my grid
          <span>(tracking only – no odds yet)</span>
        </h2>

        <div class="labels-row">
          <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span>
          <span>6</span><span>7</span><span>8</span><span>9</span><span>10</span>
        </div>

        <div class="board-wrapper">
          <div class="labels-col">
            <span>A</span><span>B</span><span>C</span><span>D</span><span>E</span>
            <span>F</span><span>G</span><span>H</span><span>I</span><span>J</span>
          </div>
          <div
            class="board"
            id="enemyShotsBoard"
            aria-label="Enemy shots on my board"
          ></div>
        </div>

        <div class="legend">
          <div class="legend-item">
            <span class="legend-swatch hit"></span> They hit me here
          </div>
          <div class="legend-item">
            <span class="legend-swatch miss"></span> They missed here
          </div>
        </div>
      </section>
    </div>

    <div class="controls">
      <span class="seg-label">Board actions:</span>
      <button id="resetMyBoard">Clear my shots</button>
      <button id="resetEnemyBoard">Clear enemy shots</button>
      <label for="strategySelect" class="strategy-label">Strategy:</label>
      <select id="strategySelect" class="strategy-select" aria-label="Select targeting strategy">
        <option value="standard">Standard</option>
        <option value="probability" selected>Probability</option>
        <option value="parity">Parity</option>
        <option value="huntTarget">Hunt/Target</option>
        <option value="edgeBias">Edge Bias</option>
      </select>
      <small>Heatmap recalculates automatically on every change.</small>
    </div>
  </div>

  <script>
    // --- Configuration ------------------------------------------------------

    const BOARD_SIZE = 10;

    // Standard Battleship fleet
    const FLEET = [
      { name: "Carrier", length: 5 },
      { name: "Battleship", length: 4 },
      { name: "Cruiser", length: 3 },
      { name: "Submarine", length: 3 },
      { name: "Destroyer", length: 2 }
    ];

    const StrategyManager = {
      strategies: {
        standard: computeStandardHeatmap,
        probability: computeProbabilityHeatmap,
        parity: computeParityHeatmap,
        huntTarget: computeHuntTargetHeatmap,
        edgeBias: computeEdgeBiasHeatmap
      },
      currentStrategy: "probability"
    };

    const STATE_UNKNOWN = 0;
    const STATE_MISS = 1;
    const STATE_HIT = 2;

    // --- Board Model --------------------------------------------------------

    function createBoardModel() {
      return Array.from({ length: BOARD_SIZE }, () =>
        Array(BOARD_SIZE).fill(STATE_UNKNOWN)
      );
    }

    const myShotsBoard = {
      id: "myShotsBoard",
      el: null,
      state: createBoardModel(),
      heat: null
    };

    const enemyShotsBoard = {
      id: "enemyShotsBoard",
      el: null,
      state: createBoardModel()
    };

    // --- Setup DOM grids ----------------------------------------------------

    function createBoardCells(boardObj, boardKey) {
      const boardEl = document.getElementById(boardObj.id);
      boardObj.el = boardEl;
      boardEl.innerHTML = "";

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.createElement("div");
          cell.className = "cell state-unknown";
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.dataset.board = boardKey;
          cell.addEventListener("click", handleCellClick);
          boardEl.appendChild(cell);
        }
      }
    }

    function handleCellClick(e) {
      const cell = e.currentTarget;
      const r = Number(cell.dataset.row);
      const c = Number(cell.dataset.col);
      const boardKey = cell.dataset.board;

      const boardObj =
        boardKey === "myShots" ? myShotsBoard : enemyShotsBoard;
      const state = boardObj.state[r][c];

      let newState;
      if (state === STATE_UNKNOWN) newState = STATE_MISS;
      else if (state === STATE_MISS) newState = STATE_HIT;
      else newState = STATE_UNKNOWN;

      boardObj.state[r][c] = newState;
      updateCellVisual(cell, newState, boardKey === "myShots");

      if (boardKey === "myShots") {
        recomputeHeatmap();
      }
    }

    function updateCellVisual(cell, state, isMyBoard) {
      cell.classList.remove("state-unknown", "state-miss", "state-hit");
      if (state === STATE_MISS) cell.classList.add("state-miss");
      else if (state === STATE_HIT) cell.classList.add("state-hit");
      else cell.classList.add("state-unknown");

      // Remove previous probability styling if any
      if (isMyBoard) {
        cell.removeAttribute("data-prob");
        cell.style.backgroundImage = "";
        cell.style.backgroundColor = "";
        cell.title = "";
      }
    }

    // --- Heatmap computation ------------------------------------------------
    // Strategies compute their own heatmap and return a BOARD_SIZE x BOARD_SIZE matrix.

    function getBoardState() {
      return {
        size: BOARD_SIZE,
        raw: myShotsBoard.state,
        cells: myShotsBoard.state.map((row) =>
          row.map((value) => {
            if (value === STATE_HIT) return "hit";
            if (value === STATE_MISS) return "miss";
            return "unknown";
          })
        )
      };
    }

    function getRemainingShips() {
      return FLEET.map((ship) => ({ ...ship }));
    }

    function recomputeHeatmap() {
      const boardState = getBoardState();
      const remainingShips = getRemainingShips();
      const strategyKey = StrategyManager.currentStrategy;
      const strategyFunc =
        StrategyManager.strategies[strategyKey] ||
        StrategyManager.strategies.standard;

      if (typeof strategyFunc !== "function") {
        console.error("Unknown strategy:", strategyKey);
        return;
      }

      const heat = strategyFunc(boardState, remainingShips);
      if (!heat) return;

      myShotsBoard.heat = heat;
      applyHeatToBoard();
    }

    function computeStandardHeatmap(boardState, remainingShips) {
      const heat = createZeroHeat(boardState.size);
      const rawState = boardState.raw;
      const hits = [];

      for (let r = 0; r < boardState.size; r++) {
        for (let c = 0; c < boardState.size; c++) {
          if (rawState[r][c] === STATE_HIT) {
            hits.push({ r, c });
          }
        }
      }

      for (const ship of remainingShips) {
        const length = ship.length || ship;
        addShipPlacementsToHeat(length, rawState, heat);
      }

      addTargetOverlay(hits, rawState, heat);
      return heat;
    }

    function computeProbabilityHeatmap(boardState, remainingShips) {
      const size = boardState.size;
      const cells = boardState.cells;
      const heat = createZeroHeat(size);

      for (const ship of remainingShips) {
        const length = ship.length || ship;
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const horizontal = gatherPlacementCells(cells, r, c, length, 0, 1);
            if (horizontal) {
              for (const [pr, pc] of horizontal) {
                if (cells[pr][pc] === "unknown" || cells[pr][pc] === "hit") {
                  heat[pr][pc] += 1;
                }
              }
            }

            const vertical = gatherPlacementCells(cells, r, c, length, 1, 0);
            if (vertical) {
              for (const [pr, pc] of vertical) {
                if (cells[pr][pc] === "unknown" || cells[pr][pc] === "hit") {
                  heat[pr][pc] += 1;
                }
              }
            }
          }
        }
      }

      return heat;
    }

    function gatherPlacementCells(cells, r, c, length, dr, dc) {
      const size = cells.length;
      const coords = [];
      for (let i = 0; i < length; i++) {
        const nr = r + dr * i;
        const nc = c + dc * i;
        if (nr < 0 || nr >= size || nc < 0 || nc >= size) {
          return null;
        }
        const status = cells[nr][nc];
        if (
          status === "miss" ||
          status === "sunk" ||
          status === "invalid"
        ) {
          return null;
        }
        coords.push([nr, nc]);
      }
      return coords;
    }

    function computeParityHeatmap(boardState) {
      const size = boardState.size;
      const cells = boardState.cells;
      const heat = createZeroHeat(size);

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (cells[r][c] !== "unknown") continue;
          heat[r][c] = (r + c) % 2 === 0 ? 1 : 0;
        }
      }

      return heat;
    }

    function computeHuntTargetHeatmap(boardState) {
      const size = boardState.size;
      const cells = boardState.cells;
      const heat = createZeroHeat(size);
      const hits = [];

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (cells[r][c] === "hit") {
            hits.push([r, c]);
          }
        }
      }

      if (!hits.length) {
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (cells[r][c] !== "unknown") continue;
            heat[r][c] = (r + c) % 2 === 0 ? 1 : 0;
          }
        }
        return heat;
      }

      const cluster = findHitCluster(hits[0], cells);
      const isHorizontal =
        cluster.length > 1 && cluster.every(([row]) => row === cluster[0][0]);
      const isVertical =
        cluster.length > 1 && cluster.every(([, col]) => col === cluster[0][1]);
      const HIGH_WEIGHT = 5;

      if (isHorizontal) {
        let minC = Infinity;
        let maxC = -Infinity;
        const row = cluster[0][0];
        cluster.forEach(([, col]) => {
          if (col < minC) minC = col;
          if (col > maxC) maxC = col;
        });
        const left = minC - 1;
        const right = maxC + 1;
        if (left >= 0 && cells[row][left] === "unknown") {
          heat[row][left] += HIGH_WEIGHT;
        }
        if (right < size && cells[row][right] === "unknown") {
          heat[row][right] += HIGH_WEIGHT;
        }
      } else if (isVertical) {
        let minR = Infinity;
        let maxR = -Infinity;
        const col = cluster[0][1];
        cluster.forEach(([row]) => {
          if (row < minR) minR = row;
          if (row > maxR) maxR = row;
        });
        const up = minR - 1;
        const down = maxR + 1;
        if (up >= 0 && cells[up][col] === "unknown") {
          heat[up][col] += HIGH_WEIGHT;
        }
        if (down < size && cells[down][col] === "unknown") {
          heat[down][col] += HIGH_WEIGHT;
        }
      } else {
        const deltas = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ];
        const [hr, hc] = cluster[0];
        for (const [dr, dc] of deltas) {
          const nr = hr + dr;
          const nc = hc + dc;
          if (
            nr >= 0 &&
            nr < size &&
            nc >= 0 &&
            nc < size &&
            cells[nr][nc] === "unknown"
          ) {
            heat[nr][nc] += HIGH_WEIGHT;
          }
        }
      }

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (cells[r][c] === "unknown" && heat[r][c] === 0) {
            heat[r][c] = (r + c) % 2 === 0 ? 1 : 0;
          }
        }
      }

      return heat;
    }

    function findHitCluster(start, cells) {
      const size = cells.length;
      const stack = [start];
      const visited = new Set();
      const cluster = [];

      while (stack.length) {
        const [r, c] = stack.pop();
        const key = r + "," + c;
        if (visited.has(key)) continue;
        visited.add(key);
        cluster.push([r, c]);

        const deltas = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ];
        for (const [dr, dc] of deltas) {
          const nr = r + dr;
          const nc = c + dc;
          if (
            nr >= 0 &&
            nr < size &&
            nc >= 0 &&
            nc < size &&
            cells[nr][nc] === "hit"
          ) {
            stack.push([nr, nc]);
          }
        }
      }

      return cluster;
    }

    function computeEdgeBiasHeatmap(boardState) {
      const size = boardState.size;
      const cells = boardState.cells;
      const heat = createZeroHeat(size);

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (cells[r][c] !== "unknown") continue;
          let weight = 1;
          const isEdge = r === 0 || r === size - 1 || c === 0 || c === size - 1;
          const isCorner =
            (r === 0 || r === size - 1) && (c === 0 || c === size - 1);

          if (isCorner) weight += 2;
          else if (isEdge) weight += 1;

          heat[r][c] = weight;
        }
      }

      return heat;
    }

    function createZeroHeat(size = BOARD_SIZE) {
      return Array.from({ length: size }, () => Array(size).fill(0));
    }

    function addShipPlacementsToHeat(length, boardState, heat) {
      const size = boardState.length;

      for (let r = 0; r < size; r++) {
        for (let c = 0; c <= size - length; c++) {
          let blocked = false;
          for (let offset = 0; offset < length; offset++) {
            const cellState = boardState[r][c + offset];
            if (cellState === STATE_MISS) {
              blocked = true;
              break;
            }
          }
          if (!blocked) {
            for (let offset = 0; offset < length; offset++) {
              heat[r][c + offset] += 1;
            }
          }
        }
      }

      for (let c = 0; c < size; c++) {
        for (let r = 0; r <= size - length; r++) {
          let blocked = false;
          for (let offset = 0; offset < length; offset++) {
            const cellState = boardState[r + offset][c];
            if (cellState === STATE_MISS) {
              blocked = true;
              break;
            }
          }
          if (!blocked) {
            for (let offset = 0; offset < length; offset++) {
              heat[r + offset][c] += 1;
            }
          }
        }
      }
    }

    function addTargetOverlay(hits, boardState, heat) {
      if (!hits.length) return;

      const size = boardState.length;
      const ADJ_WEIGHT = 5;
      const LINE_END_WEIGHT = 10;

      const inBounds = (r, c) => r >= 0 && r < size && c >= 0 && c < size;

      for (const { r, c } of hits) {
        const neighbors = [
          { r: r - 1, c },
          { r: r + 1, c },
          { r, c: c - 1 },
          { r, c: c + 1 }
        ];
        for (const { r: nr, c: nc } of neighbors) {
          if (!inBounds(nr, nc)) continue;
          if (boardState[nr][nc] !== STATE_UNKNOWN) continue;
          heat[nr][nc] += ADJ_WEIGHT;
        }
      }

      const hitSet = new Set(hits.map(({ r, c }) => r + "," + c));

      function boostEnds(dr, dc) {
        for (const { r, c } of hits) {
          const prevR = r - dr;
          const prevC = c - dc;
          if (hitSet.has(prevR + "," + prevC)) continue;

          let curR = r;
          let curC = c;
          while (hitSet.has(curR + "," + curC)) {
            curR += dr;
            curC += dc;
          }
          if (!inBounds(curR, curC)) continue;
          if (boardState[curR][curC] !== STATE_UNKNOWN) return;
          heat[curR][curC] += LINE_END_WEIGHT;
        }
      }

      boostEnds(0, 1);
      boostEnds(1, 0);
    }

    function applyHeatToBoard() {
      const boardEl = myShotsBoard.el;
      const heat = myShotsBoard.heat;
      if (!boardEl || !heat) return;

      // Compute total and max for normalization
      let total = 0;
      let max = 0;
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          // Only consider unknown cells
          if (myShotsBoard.state[r][c] !== STATE_UNKNOWN) continue;
          const val = heat[r][c];
          if (val <= 0) continue;
          total += val;
          if (val > max) max = val;
        }
      }

      const cells = boardEl.querySelectorAll(".cell");
      cells.forEach((cell) => {
        const r = Number(cell.dataset.row);
        const c = Number(cell.dataset.col);
        const state = myShotsBoard.state[r][c];

        // Clear all probability styling first
        cell.removeAttribute("data-prob");
        if (state !== STATE_UNKNOWN || max === 0) {
          // Let normal CSS handle background for hits/misses
          if (state === STATE_UNKNOWN) {
            cell.style.backgroundImage = "";
            cell.style.backgroundColor = "";
          }
          cell.title = "";
          return;
        }

        const value = heat[r][c];
        if (value <= 0) {
          cell.style.backgroundImage = "";
          cell.style.backgroundColor = "";
          cell.title = "";
          return;
        }

        const prob = value / total;
        const intensity = value / max;
        const color = probToColor(intensity);

        cell.dataset.prob = prob.toFixed(3);
        cell.style.backgroundImage = `radial-gradient(circle at 30% 20%, rgba(255,255,255,0.12), transparent 55%), linear-gradient(135deg, ${color}, #050a0f)`;
        cell.title = `~${(prob * 100).toFixed(1)}% chance`;
      });
    }

    // Map [0,1] -> color between low/mid/high
    function probToColor(t) {
      // clamp
      t = Math.max(0, Math.min(1, t));

      // We'll do a simple two-stop: low->mid for t<0.5, mid->high for t>=0.5
      const hexToRgb = (hex) => {
        hex = hex.replace("#", "");
        const n = parseInt(hex, 16);
        return {
          r: (n >> 16) & 255,
          g: (n >> 8) & 255,
          b: n & 255
        };
      };

      const rgbToHex = (r, g, b) =>
        "#" +
        [r, g, b]
          .map((x) => {
            const h = x.toString(16);
            return h.length === 1 ? "0" + h : h;
          })
          .join("");

      const low = hexToRgb(getComputedStyle(document.documentElement)
        .getPropertyValue("--prob-low")
        .trim() || "#263238");

      const mid = hexToRgb(getComputedStyle(document.documentElement)
        .getPropertyValue("--prob-mid")
        .trim() || "#4fc3f7");

      const high = hexToRgb(getComputedStyle(document.documentElement)
        .getPropertyValue("--prob-high")
        .trim() || "#ffab40");

      let a, b, localT;
      if (t < 0.5) {
        a = low;
        b = mid;
        localT = t * 2;
      } else {
        a = mid;
        b = high;
        localT = (t - 0.5) * 2;
      }

      const r = Math.round(a.r + (b.r - a.r) * localT);
      const g = Math.round(a.g + (b.g - a.g) * localT);
      const bCh = Math.round(a.b + (b.b - a.b) * localT);
      return rgbToHex(r, g, bCh);
    }

    // --- Reset helpers ------------------------------------------------------

    function resetBoard(boardObj, boardKey) {
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          boardObj.state[r][c] = STATE_UNKNOWN;
        }
      }

      const cells = boardObj.el.querySelectorAll(".cell");
      cells.forEach((cell) =>
        updateCellVisual(cell, STATE_UNKNOWN, boardKey === "myShots")
      );

      if (boardKey === "myShots") {
        recomputeHeatmap();
      }
    }

    // --- Init ---------------------------------------------------------------

    function init() {
      createBoardCells(myShotsBoard, "myShots");
      createBoardCells(enemyShotsBoard, "enemyShots");

      document
        .getElementById("resetMyBoard")
        .addEventListener("click", () =>
          resetBoard(myShotsBoard, "myShots")
        );
      document
        .getElementById("resetEnemyBoard")
        .addEventListener("click", () =>
          resetBoard(enemyShotsBoard, "enemyShots")
        );

      const strategySelect = document.getElementById("strategySelect");
      if (strategySelect) {
        strategySelect.value = StrategyManager.currentStrategy;
        strategySelect.addEventListener("change", (event) => {
          StrategyManager.currentStrategy = event.target.value;
          recomputeHeatmap();
        });
      }

      recomputeHeatmap();
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
