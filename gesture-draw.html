<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Gesture Drawing (Styled like Tape & Memory)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Styling echoes your calculator’s UI: dark card, rounded pill buttons, memory row, modal with “Calculator Instructions” + Close -->
  <style>
    :root{
      --bg: #0e1117;
      --card: #131a24;
      --muted: #9aa4b2;
      --text: #e6edf3;
      --btn: #1b2430;
      --shadow: 0 16px 40px rgba(0,0,0,.45);
      --r: 14px;

      /* accents inspired by your green/blue calculator theme */
      --accent1: #32d583; /* green */
      --accent2: #60a5fa; /* blue */
      --accent1-ghost: rgba(50,213,131,.18);
      --accent2-ghost: rgba(96,165,250,.18);
    }
    html,body{height:100%}
    body{
      margin:0; background:
        radial-gradient(1200px 800px at 20% -10%, #0f1824 0%, transparent 60%),
        radial-gradient(1400px 900px at 120% 120%, #0b131d 0%, transparent 60%),
        linear-gradient(#0e1117,#0b1016);
      color:var(--text); font: 14px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      display:flex; align-items:center; justify-content:center; padding:20px;
    }
    .app{
      width:min(100vw, 1024px);
      background:var(--card);
      border-radius: calc(var(--r) + 2px);
      box-shadow: var(--shadow);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.04);
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .brand{font-weight:600; letter-spacing:.2px; opacity:.9}
    .memory-row{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    }
    .pill{
      background:var(--btn);
      color:var(--text);
      padding:8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 2px 8px rgba(0,0,0,.35);
      user-select:none; cursor:pointer;
      transition: transform .05s ease, box-shadow .12s ease, background .12s;
      font-weight:600; letter-spacing:.2px;
    }
    .pill:active{ transform: translateY(1px); }
    .pill.green{ outline: 1px solid var(--accent1-ghost); }
    .pill.blue{ outline: 1px solid var(--accent2-ghost); }
    .pill.badge { padding:6px 10px; font-weight:700; font-size:12px; opacity:.9 }
    .divider{width:1px; height:28px; background:rgba(255,255,255,.06); margin:0 6px}

    .canvas-wrap{
      position:relative; background:#0a0f14;
      display:grid; place-items:center;
    }
    canvas{ display:block; width:100%; height:auto; background:#0a0f14 }
    .hud{
      position:absolute; inset:10px 12px auto auto;
      padding:6px 10px; background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.07);
      border-radius:10px; font-size:12px; color:#c7d0db;
      backdrop-filter: blur(4px);
    }

    /* Modal patterned after your Instructions dialog (with Close) */
    .modal-backdrop{
      position:fixed; inset:0; display:none; place-items:center;
      background:rgba(0,0,0,.55); z-index:50;
    }
    .modal{ width:min(92vw, 720px); background:var(--card); border-radius:16px; box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,.06); padding:18px 18px 16px }
    .modal h2{ margin:6px 0 10px; font-size:18px; letter-spacing:.2px }
    .modal .body{ color:#cad2dd; font-size:14px }
    .modal .body ul{ margin:8px 0 0 18px }
    .modal .foot{ display:flex; justify-content:flex-end; gap:8px; margin-top:14px }
    .modal .close{ background:var(--btn); }
    .show{ display:grid }

    /* Small helper swatches row (visual echo of fraction row) */
    .swatches{
      display:flex; gap:8px; padding:10px 12px; border-top:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(0,0,0,.12), rgba(255,255,255,.02));
      flex-wrap:wrap;
    }
    .swatch{
      width:28px; height:28px; border-radius:999px; cursor:pointer;
      border:1px solid rgba(255,255,255,.08); box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 1px 6px rgba(0,0,0,.35);
    }
    .size-pill{ padding:6px 10px; font-weight:700; letter-spacing:.2px }
  </style>

  <!-- p5 for canvas + UI painting -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <!-- MediaPipe Hands (stable Tasks API) -->
  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.6";

    // ---------- Stable configuration ----------
    const W = 960, H = 540;
    const PINCH_DRAW = 0.055;     // thumb–index
    const PINCH_ERASE = 0.055;    // thumb–middle
    const PINCH_UNDO  = 0.055;    // thumb–ring
    const PINCH_REDO  = 0.055;    // thumb–pinky
    const SMOOTH_K = 0.25;
    const FPS_GUARD = 15;

    // Runtime handles
    let video, handLandmarker, ready=false;
    let strokesLayer, uiLayer;
    let px=null, py=null, sx=null, sy=null;

    // Strokes model (stable & serializable)
    const strokes = [];
    const redoStack = [];
    let currentStroke = null;

    // Brush model
    let brushColor = [255,255,255,200];
    let brushSize = 6;

    // Landmark indices (stable across MediaPipe Hands)
    const TI=8, TT=4, MT=12, RT=16, PT=20;

    // Utilities
    const clamp=(n,a,b)=>Math.min(Math.max(n,a),b);
    const lerp=(a,b,t)=>a+(b-a)*t;
    const dist2=(x1,y1,x2,y2)=>Math.hypot(x1-x2, y1-y2);
    const map=(n,a,b,c,d)=>(n-a)*(d-c)/(b-a)+c;

    function screenXY(norm){ return [norm.x * W, norm.y * H]; }

    // Modal controls
    function showModal(on=true){
      document.querySelector('.modal-backdrop').classList.toggle('show', on);
    }

    // ---------- Stroke drawing using stable canvas compositing ----------
    function drawSegmentOn(g, x0,y0,x1,y1, width, rgba, mode){
      const ctx = g.drawingContext; // HTMLCanvasRenderingContext2D
      ctx.save();
      if (mode === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';  // robust & stable
        ctx.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        const [r,gc,b,a] = rgba;
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = `rgba(${r},${gc},${b},${clamp(a/255,0,1)})`;
      }
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x0,y0); ctx.lineTo(x1,y1);
      ctx.stroke();
      ctx.restore();
    }

    function beginStroke(mode,color,width){
      currentStroke = {mode, color:[...color], width, points:[]};
    }
    function appendPoint(x,y){
      const pts = currentStroke.points;
      pts.push({x,y});
      if (pts.length>1){
        const p0 = pts[pts.length-2], p1 = pts[pts.length-1];
        drawSegmentOn(strokesLayer, p0.x,p0.y, p1.x,p1.y, currentStroke.width, currentStroke.color, currentStroke.mode);
      }
    }
    function commitStroke(){
      if (currentStroke && currentStroke.points.length>1){
        strokes.push(currentStroke);
        redoStack.length = 0; // new action clears redo
      }
      currentStroke = null;
    }
    function redrawAll(){
      const g = strokesLayer; g.clear();
      // replay strokes deterministically
      for (const s of strokes){
        for (let i=1;i<s.points.length;i++){
          const p0=s.points[i-1], p1=s.points[i];
          drawSegmentOn(g, p0.x,p0.y, p1.x,p1.y, s.width, s.color, s.mode);
        }
      }
    }
    function undo(){ if (strokes.length){ redoStack.push(strokes.pop()); redrawAll(); } }
    function redo(){ if (redoStack.length){ strokes.push(redoStack.pop()); redrawAll(); } }

    function palmOpen(lm){
      // Robust heuristic: average tip-to-wrist distance exceeds threshold
      const wrist = lm[0], tips=[TI,MT,RT,PT,TT].map(i=>lm[i]);
      const avg = tips.reduce((s,t)=>s+Math.hypot(t.x-wrist.x,t.y-wrist.y),0)/tips.length;
      return avg > 0.35;
    }

    // ---------- p5 ----------
    window.setup = async function(){
      createCanvas(W,H); background('#0a0f14');
      strokesLayer = createGraphics(W,H);
      uiLayer = createGraphics(W,H);

      video = createCapture({ video: { facingMode: "user", width: W, height: H } });
      video.size(W,H); video.hide();

      // Stable Tasks API load
      const resolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.6/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(resolver, {
        baseOptions: { modelAssetPath: "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.6/wasm/hand_landmarker.task" },
        numHands: 2, minHandDetectionConfidence: 0.5, minHandPresenceConfidence: 0.5, minTrackingConfidence: 0.5,
        runningMode: "VIDEO"
      });
      ready = true;
    };

    window.draw = function(){
      // camera faint in background
      push(); tint(255,40); image(video,0,0,width,height); pop();

      if (!ready){ image(strokesLayer,0,0); image(uiLayer,0,0); return; }

      const fps = frameRate();
      const throttle = fps < FPS_GUARD ? 2 : 1;
      if (frameCount % throttle !== 0){
        image(strokesLayer,0,0); image(uiLayer,0,0); return;
      }

      const result = handLandmarker.detectForVideo(video.elt, performance.now());
      uiLayer.clear();

      if (!result || !Array.isArray(result.landmarks) || result.landmarks.length===0){
        commitStroke(); image(strokesLayer,0,0); image(uiLayer,0,0); return;
      }

      // Identify hands defensively
      let left=null, right=null;
      if (Array.isArray(result.handednesses) && result.handednesses.length===result.landmarks.length){
        for (let i=0;i<result.landmarks.length;i++){
          const label = (result.handednesses[i] && result.handednesses[i][0] && result.handednesses[i][0].categoryName) || "";
          if (label==="Left") left = result.landmarks[i];
          else if (label==="Right") right = result.landmarks[i];
        }
      }
      // fallback by x
      if ((!left || !right) && result.landmarks.length===2){
        const [a,b] = result.landmarks;
        left = (a[0].x < b[0].x) ? a : b;
        right = (a[0].x < b[0].x) ? b : a;
      } else if (result.landmarks.length===1 && !right){
        right = result.landmarks[0];
      }

      // Left-hand menu (open palm toggles)
      const menuBtn = document.getElementById('menuToggle');
      if (left && palmOpen(left)){
        menuBtn.classList.add('green'); // subtle cue
      } else {
        menuBtn.classList.remove('green');
      }

      // Palette (same radial gesture as earlier; minimal HUD dot only)
      if (right){
        const idx = right[TI], th = right[TT], mid=right[MT], ring=right[RT], pink=right[PT];
        const [ix,iy] = screenXY(idx);

        // Smooth cursor
        if (sx==null){ sx=ix; sy=iy; }
        sx += SMOOTH_K*(ix-sx);
        sy += SMOOTH_K*(iy-sy);

        // HUD cursor
        uiLayer.push(); uiLayer.noStroke(); uiLayer.fill(255,190); uiLayer.circle(sx,sy,6); uiLayer.pop();

        // Distances (normalized)
        const dDraw = Math.hypot(idx.x-th.x, idx.y-th.y);
        const dErs  = Math.hypot(mid.x-th.x, mid.y-th.y);
        const dU    = Math.hypot(ring.x-th.x, ring.y-th.y);
        const dR    = Math.hypot(pink.x-th.x, pink.y-th.y);

        if (dU < PINCH_UNDO) undo();
        else if (dR < PINCH_REDO) redo();

        // Dynamic width & opacity from speed + pinch
        let speed = 0; if (px!=null) speed = Math.hypot(sx-px, sy-py);
        const dynW = clamp(lerp(brushSize*0.8, brushSize*1.6, clamp(speed/18,0,1)), 1, 64);
        const pinchT = clamp((0.09 - dDraw)/0.09, 0, 1);
        const alpha = Math.round(lerp(120,255,pinchT));

        const wantsBrush = dDraw < PINCH_DRAW && !(dErs < PINCH_ERASE);
        const wantsEraser = dErs < PINCH_ERASE && !(dDraw < PINCH_DRAW);

        if (wantsBrush || wantsEraser){
          const mode = wantsEraser ? 'eraser' : 'brush';
          const col  = wantsEraser ? [0,0,0,255] : [brushColor[0], brushColor[1], brushColor[2], alpha];

          if (!currentStroke || currentStroke.mode!==mode){
            commitStroke();
            beginStroke(mode, col, dynW);
            appendPoint(sx,sy);
          } else {
            currentStroke.color = col;
            currentStroke.width = dynW;
            appendPoint(sx,sy);
          }
        } else {
          commitStroke();
        }

        px=sx; py=sy;
      } else {
        commitStroke();
      }

      // Composite layers
      image(strokesLayer,0,0);
      image(uiLayer,0,0);
    };

    // Keyboard fallbacks
    window.keydown = window.keyPressed = function(e){
      const k = (e && e.key) || window.key;
      if (!k) return;
      if (k==='z' || k==='Z') undo();
      if (k==='y' || k==='Y') redo();
      if (k==='s' || k==='S') saveCanvas('gesture-doodle','png');
      if (k==='[') brushSize = clamp(brushSize-1,1,64);
      if (k===']') brushSize = clamp(brushSize+1,1,64);
    };

    // UI hooks
    window.addEventListener('DOMContentLoaded', ()=>{
      // memory-like top row controls
      document.getElementById('undoBtn').onclick = undo;
      document.getElementById('redoBtn').onclick = redo;
      document.getElementById('saveBtn').onclick = ()=>saveCanvas('gesture-doodle','png');
      document.getElementById('clearBtn').onclick = ()=>{ strokes.length=0; redoStack.length=0; redrawAll(); };

      // Menu modal
      const backdrop = document.querySelector('.modal-backdrop');
      document.getElementById('menuToggle').onclick = ()=> showModal(true);
      document.getElementById('closeModal').onclick = ()=> showModal(false);
      backdrop.addEventListener('click', e => { if (e.target===backdrop) showModal(false); });

      // Swatches + sizes (visual echo of fraction row)
      document.querySelectorAll('.swatch[data-c]').forEach(el=>{
        el.onclick = ()=>{
          const [r,g,b] = el.dataset.c.split(',').map(Number);
          brushColor = [r,g,b,200];
        };
      });
      document.querySelectorAll('[data-size]').forEach(el=>{
        el.onclick = ()=>{ brushSize = clamp(parseInt(el.dataset.size,10)||6,1,64); };
      });
    });
  </script>
</head>
<body>
  <div class="app">
    <!-- Top bar with memory-style buttons + menu -->
    <div class="topbar">
      <div class="brand">Gesture Draw</div>
      <div class="memory-row">
        <!-- echoing MC/M1.. look/feel as pills -->
        <div id="undoBtn" class="pill blue badge">Undo</div>
        <div id="redoBtn" class="pill blue badge">Redo</div>
        <div class="divider"></div>
        <div id="saveBtn" class="pill green badge">Save</div>
        <div id="clearBtn" class="pill badge">Clear</div>
        <div class="divider"></div>
        <div id="menuToggle" class="pill">menu</div>
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="hud">Pinch=index draw · thumb–middle eraser · thumb–ring undo · thumb–pinky redo</div>
      <!-- p5 will insert the canvas here -->
    </div>

    <!-- Swatches / sizes row (visual analogy to your fraction row) -->
    <div class="swatches">
      <div class="swatch" style="background:#ffffff" data-c="255,255,255" title="White"></div>
      <div class="swatch" style="background:#000000" data-c="0,0,0" title="Black"></div>
      <div class="swatch" style="background:#32d583" data-c="50,213,131" title="Green"></div>
      <div class="swatch" style="background:#60a5fa" data-c="96,165,250" title="Blue"></div>
      <div class="swatch" style="background:#f59e0b" data-c="245,158,11" title="Amber"></div>
      <div class="swatch" style="background:#ef4444" data-c="239,68,68" title="Red"></div>
      <div class="swatch" style="background:#a855f7" data-c="168,85,247" title="Violet"></div>

      <div class="divider" style="height:28px"></div>
      <div class="pill size-pill">Size</div>
      <div class="pill size-pill" data-size="4">1/16</div>
      <div class="pill size-pill" data-size="6">1/8</div>
      <div class="pill size-pill" data-size="9">1/4</div>
      <div class="pill size-pill" data-size="12">3/8</div>
      <div class="pill size-pill" data-size="16">1/2</div>
    </div>
  </div>

  <!-- Instructions Modal (styled like your "Calculator Instructions"/Close dialog) -->
  <div class="modal-backdrop">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Instructions">
      <h2>Calculator Instructions</h2>
      <div class="body">
        <p>This app uses your webcam and hand gestures to draw:</p>
        <ul>
          <li><b>Pinch (thumb–index)</b>: draw</li>
          <li><b>Thumb–middle pinch</b>: eraser</li>
          <li><b>Thumb–ring</b>: undo · <b>Thumb–pinky</b>: redo</li>
          <li><b>[ / ]</b> keys: brush size · <b>S</b>: save PNG</li>
        </ul>
      </div>
      <div class="foot">
        <div id="closeModal" class="pill close">Close</div>
      </div>
    </div>
  </div>
</body>
</html>
